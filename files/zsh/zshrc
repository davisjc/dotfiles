#
# This dotfiles setup is largely inspired by hbw's dotfiles. I was also
# frustrated by the bloat in oh-my-zsh and decided to rip out the parts I
# wanted. I still use some of the lighter-weight components of oh-my-zsh, e.g.,
# a few plugins.
#
# hbw's dotfiles: https://bitbucket.org/hbw/dotfiles-min
# oh-my-zsh: https://github.com/robbyrussell/oh-my-zsh
#
# @author: Johnathan Davis
#

export DOTFILES="$HOME/dot"
export DOTFILES_LOCAL="$HOME/dot.local"
PATH=$PATH:$DOTFILES/bin

# Colors!
source $HOME/.dir_colors
autoload -U colors && colors;

# Load some plugins.
plugins=(colored-man sprunge extract)
for plugin in "${plugins[@]}"; do
    source $DOTFILES/files/zsh/plugins/$plugin/$plugin.plugin.zsh
done

# ZSH completion (man zshcompsys).
zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _ignored _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' expand prefix suffix
zstyle ':completion:*' format ''
zstyle ':completion:*' glob 1
zstyle ':completion:*' ignore-parents parent pwd ..
zstyle ':completion:*' insert-unambiguous false
zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"
zstyle ':completion:*' list-prompt '%SAt %p: Hit TAB for more, or the character to insert%s'
zstyle ':completion:*' list-suffixes true
zstyle ':completion:*' matcher-list '' '+m:{[:lower:]}={[:upper:]}' '+r:|[._-]=** r:|=**' 'l:|=* r:|=*'
zstyle ':completion:*' max-errors 3
zstyle ':completion:*' menu select=1
zstyle ':completion:*' original true
zstyle ':completion:*' preserve-prefix '//[^/]##/'
zstyle ':completion:*' select-prompt '%SScrolling active: current selection at %p%s'
zstyle ':completion:*' substitute 1
zstyle ':completion:*' verbose true
zstyle ':completion:*:killall:*' command 'ps -u $USER -o cmd'

# ZSH options (man zshoptions).
setopt always_to_end # move cursor to end of word after completion
setopt auto_pushd # automatically pushd on cd
setopt complete_in_word # perform bi-directional completion from position
setopt extended_glob # use #,~,^ for filename generation
setopt extended_history # save time info to histfile
setopt hist_ignore_space # don't write space-prefixed commands to histfile
setopt hist_verify # reload history expansion in command buffer
setopt inc_append_history # multiple zsh instances write to same histfile
setopt long_list_jobs # list jobs in long format
setopt no_match # print error when no match for filename generation
setopt notify # print status of background jobs immediately
setopt prompt_subst # perform expansion in prompts
setopt pushd_ignore_dups # don't pushd duplicate dirs
setopt pushd_silent # suppress popd output
unsetopt beep # be quiet, you..
unsetopt flow_control # don't use ctrl-s/ctrl-q for shell flow control
unsetopt share_history # favor inc_append_history

# Load ZSH completion.
autoload -Uz compinit
compinit -i

# Define ZSH's definition of a "word".
autoload -U select-word-style
select-word-style bash

# Compile zcompdump if necessary.
if [ ~/.zcompdump -nt ~/.zcompdump.zwc -o ! -e ~/.zcompdump.zwc ]; then
  zcompile ~/.zcompdump
fi

# Shell history.
HISTSIZE=10000
SAVEHIST=1000

# Setup vim keys (bindkey -v needs to happen before the mass key[] fix).
bindkey -v
bindkey "^?" backward-delete-char
bindkey "^W" backward-kill-word
bindkey "^H" backward-delete-char
bindkey "^U" backward-kill-line
KEYTIMEOUT=0 # don't delay esc

# Fix bindings in zle (pulled from arch wiki).
typeset -A key
key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init () {
        printf '%s' "${terminfo[smkx]}"
    }
    function zle-line-finish () {
        printf '%s' "${terminfo[rmkx]}"
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi

# Vi mode indicator
function vi_mode_prompt_info() {
    local MODE_INDICATOR="%{$fg[magenta]%}<%{$reset_color%}%{$fg[magenta]%}<<%{$reset_color%}"
    echo "${${KEYMAP/vicmd/$MODE_INDICATOR}/(main|viins)/}"
}

# Git branch/dirty indicator
function git_status_info() {
    local branch="$(git symbolic-ref --short HEAD 2>/dev/null)"
    if [ "$branch" ]; then
        local git_status="$(git status --untracked-files=no --porcelain 2>/dev/null)"
        if [ "$git_status" ]; then
            local dirty="*";
        fi
        echo "<$branch$dirty>"
    fi
}

# Runs each time before the shell prompt is printed. We override this to allow
# zshrc scripts source'd after this one to hook into the prompt by setting
# $STATUS_EXT. However, we don't allow the prompt itself to be extended because
# that causes too many strange issues with redrawing and such.
function precmd() {
    local _return_code="%(?.%{$fg[green]%}%{$fg[green]%}0 %{$reset_color%}.%{$fg[red]%}%{$fg[red]%}%? %{$reset_color%})"

    local _is_root=$(( 0 == $EUID ))
    local _host
    if [[ 1 == $_is_root ]]; then
        _host="%{${fg[red]}%}%n@%m%{${reset_color}%}"
    else
        _host="%{${fg[white]}%}%n@%m%{${reset_color}%}"
    fi

    if [ ! -z $SSH_CONNECTION ]; then
        _host="%{$fg[green]%}ssh://%{$reset_color%}$_host"
    fi

    local _symbol
    if [[ 1 == $_is_root ]]; then
        _symbol="%{${fg[red]}%}#%{${reset_color}%}"
    else
        _symbol="%{${fg[yellow]}%}$%{${reset_color}%}"
    fi

    PROMPT="%{${_host}%} %{${fg[yellow]}%}%3~%{$reset_color%}${fg[cyan]}$reset_color$STATUS_EXT"$'\n'
    PROMPT="$PROMPT$_return_code$_symbol%{${reset_color}%} "
    RPROMPT=' %{${fg[cyan]}%}$(git_status_info)%{${reset_color}%}'
    export PROMPT
    export RPROMPT
}

# Fix some binds.
bindkey "^R" history-incremental-search-backward

# Completely disable ctrl-s/ctrl-q shell flow control.
stty -ixon

# Aliases/functions.
alias gd='git diff'
alias gds='git diff --staged'
alias gs='git status'
alias info='info --vi-keys'
alias la='ls -a'
alias ll='ls -lh'
alias lla='ls -lah'
if [ $(uname) = "Linux" ]; then
    alias ls='LC_COLLATE=C ls --color=auto --group-directories-first'
else
hash gnuls 2> /dev/null
if [ $? -eq 0 ]; then
    alias ls='LC_COLLATE=C gnuls --color=auto --group-directories-first'
fi
fi
alias tmux='tmux -2'
alias ta='tmux attach-session -t'
alias tl='tmux list-sessions'
alias tn='tmux new-session -s'
alias feh='feh -q --scale-down --image-bg black'
function gl() {
    local n=$([ -z $1 ] && echo 10 || echo $1)
    git log --pretty=oneline HEAD~$n..HEAD
}

# Load Linux stuff.
if [ -e $HOME/.zshrc.linux ]; then
    source $HOME/.zshrc.linux
fi

# Load OS X stuff.
if [ -e $HOME/.zshrc.osx ]; then
    source $HOME/.zshrc.osx
fi

# Load machine-specific stuff.
if [ -e $HOME/.zshrc.loc ]; then
    source $HOME/.zshrc.loc
fi

zsh -c echo derp
